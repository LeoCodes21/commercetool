package commands

import (
	"encoding/json"
	"fmt"
	"github.com/LeoCodes21/commercetool/lib"
	"os"
	"strings"
)

type CarConfigItem struct {
	CatalogTitle     string `json:"catalog_title"`
	ShortDescription string `json:"short_description"`
	LongDescription  string `json:"long_description"`
	Name             string `json:"name"`
	Icon             string `json:"icon"`
	SubType          string `json:"sub_type"`
}

type CarConfig struct {
	CarName string          `json:"car_name"`
	Items   []CarConfigItem `json:"items"`
}

type GenerateSpecificScriptCmd struct {
	CarConfigPath    string `arg:"" name:"config" help:"The path to the CarConfig file" type:"path"`
	ScriptOutputPath string `arg:"" name:"out-path" help:"The path (including file name) where the script should be created" type:"path"`
}

func (g *GenerateSpecificScriptCmd) Run(_ *Context) error {
	fmt.Printf("Generate specific script from config file: %s\n", g.CarConfigPath)

	scriptFile, err := os.Create(g.ScriptOutputPath)

	if err != nil {
		return err
	}

	defer scriptFile.Close()

	configFile, err := os.Open(g.CarConfigPath)
	if err != nil {
		return err
	}

	defer configFile.Close()

	var carConfig CarConfig

	err = json.NewDecoder(configFile).Decode(&carConfig)

	if err != nil {
		return err
	}

	scriptLines := []string{"# Generated by CommerceTool by heyitsleo"}
	carConfig.CarName = strings.ToUpper(carConfig.CarName)
	carNameHash := lib.BinHash(carConfig.CarName)

	for _, item := range carConfig.Items {
		itemName := fmt.Sprintf("%s_%s", carConfig.CarName, item.Name)
		itemNameBinHash := lib.BinHash(itemName)
		itemNameBinHashStr := fmt.Sprintf("0x%08x", itemNameBinHash)
		itemNameHash := lib.VltHash(itemNameBinHashStr)

		{
			addNodeLine := fmt.Sprintf("add_node virtualitem 0x%08x", itemNameHash)
			longDescriptionLine := fmt.Sprintf("update_field virtualitem 0x%08x longdescription \"%s\"", itemNameHash, item.LongDescription)
			shortDescriptionLine := fmt.Sprintf("update_field virtualitem 0x%08x shortdescription \"%s\"", itemNameHash, item.ShortDescription)
			typeLine := fmt.Sprintf("update_field virtualitem 0x%08x type \"%s\"", itemNameHash, "visualpart")
			itemNameLine := fmt.Sprintf("update_field virtualitem 0x%08x itemName \"%s\"", itemNameHash, itemName)
			titleLine := fmt.Sprintf("update_field virtualitem 0x%08x title \"%s\"", itemNameHash, item.CatalogTitle)
			hashLine := fmt.Sprintf("update_field virtualitem 0x%08x hash %d", itemNameHash, itemNameBinHash)
			iconLine := fmt.Sprintf("update_field virtualitem 0x%08x icon \"%s\"", itemNameHash, item.Icon)
			subTypeLine := fmt.Sprintf("update_field virtualitem 0x%08x subType \"%s\"", itemNameHash, item.SubType)

			itemLineGroup := []string{addNodeLine, longDescriptionLine, shortDescriptionLine, typeLine, itemNameLine, titleLine, hashLine, iconLine, subTypeLine}

			scriptLines = append(scriptLines, itemLineGroup...)
		}

		{
			addNodeLine := fmt.Sprintf("add_node visualpart 0x%08x", itemNameHash)
			hashLine := fmt.Sprintf("update_field visualpart 0x%08x visualPartHash %d", itemNameHash, itemNameBinHash)
			carHashLine := fmt.Sprintf("append_array visualpart 0x%08x baseCarHashes %d", itemNameHash, carNameHash)

			itemLineGroup := []string{
				addNodeLine,
				hashLine,
				fmt.Sprintf("add_field visualpart 0x%08x baseCarHashes", itemNameHash),
				carHashLine,
			}

			scriptLines = append(scriptLines, itemLineGroup...)
		}
	}

	for _, l := range scriptLines {
		_, err = fmt.Fprintln(scriptFile, l)
		if err != nil {
			return err
		}
	}

	return nil
}
